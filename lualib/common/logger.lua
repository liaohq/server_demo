---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by lhq.
--- DateTime: 2024/10/8 16:38
--- 日志模块

local logger = {}

local logFileDirectory = "log"
local maxLogFileSize = 50 * 1024 * 1024  -- 50MB
local currentLogFileIndex = 1
local currentLogFileSize = 0
local fileHandle = nil

-- 简单的 trim 函数实现
local function trim(s)
    return s:match("^%s*(.-)%s*$")
end

-- 检查目录是否存在的函数
local function directoryExists(path)
    -- 使用 `ls` 命令检查目录是否存在，并捕获其输出
    local file = io.popen("ls -d " .. path, "r")
    local output = file:read("*all")
    file:close()

    -- 去除输出两端的空白，并检查是否包含目录名
    local trimmed_output = trim(output)

    -- 如果输出包含目录名，则目录存在
    return trimmed_output == path
end

-- 创建目录的函数（Unix-like 系统）
local function createDirectory(path)
    -- 使用 `mkdir -p` 命令创建目录，`-p` 选项会创建所有必要的父目录
    local status, err = os.execute("mkdir -p " .. path)
    if status ~= 0 then
        error("无法创建目录: " .. err)
    end
end

-- 打开日志文件，如果文件不存在则创建它
local function openLogFile(logFilePath)
    if not directoryExists(logFileDirectory) then
        createDirectory(logFileDirectory)
    end

    local fileName = string.format("%s/%s_%d", logFileDirectory, logFilePath, currentLogFileIndex)
    fileHandle = io.open(fileName, "a")
    if not fileHandle then
        error("无法打开日志文件: " .. logFilePath)
    end
end

-- 关闭日志文件
local function closeLogFile()
    if fileHandle then
        fileHandle:close()
        fileHandle = nil
    end
end

-- 检查是否需要打开新的日志文件
local function checkAndOpenNewLogFile()
    if currentLogFileSize >= maxLogFileSize then
        closeLogFile()

        currentLogFileIndex = currentLogFileIndex + 1
        currentLogFileSize = 0

        openLogFile(logger.logFilePath)
    end
end

-- 写入日志信息
local function writeLog(level, message)
    local timestamp = os.date("%Y-%m-%d %H:%M:%S")

    local info = debug.getinfo(3, "Sl") -- 获取调用者的源信息，"Sl" 表示短源文件名和行号
    local fileName = info.short_src--info.source:gsub("^@?", "") -- 移除可能的 "@" 前缀
    local lineNumber = info.currentline
    local log_entry = string.format("[%s] [%s] %s:%s %s\n", timestamp, level, fileName, lineNumber, message)

    local entry_size = #log_entry


    -- 先检查大小，再写入（避免写入后检查导致的超界）
    if currentLogFileSize + entry_size > maxLogFileSize then
        checkAndOpenNewLogFile()  -- 这会关闭当前文件并打开一个新的
    end

    fileHandle:write(log_entry)
    fileHandle:flush()
    print("fileHandle:", fileHandle, log_entry, entry_size)
    currentLogFileSize = currentLogFileSize + entry_size
end

-- 设置日志级别（可选）
local log_levels = {
    DEBUG = "DEBUG",
    INFO = "INFO",
    WARN = "WARN",
    ERROR = "ERROR"
}

-- 日志函数
function logger.init(logFilePath)
    logger.logFilePath = logFilePath
    openLogFile(logFilePath)
end

function logger.shutdown()
    closeLogFile(logger.file)
end

function logger.log(level, message)
    writeLog(log_levels[level] or "UNKNOWN", message)
end

function logger.logDebug(message)
    return logger.log("DEBUG", message)
end

function logger.logInfo(message)
    return logger.log("INFO", message)
end

function logger.logWarn(message)
    return logger.log("WARN", message)
end

function logger.logError(message)
    return logger.log("ERROR", message)
end


-- 使用示例
function logger.test()
    local logFilePath = "gs.log"
    logger.init(logFilePath)

    for i=1, 1000000 do
        logger.logDebug("程序已启动" .. i)
        logger.logInfo("这是一个调试信息".. i)
        logger.logWarn("这是一个警告信息".. i)
        logger.logError("这是一个错误信息".. i)
    end

    logger.shutdown()
end

--logger.test()

return logger

